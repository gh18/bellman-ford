Алгоритм Беллмана-Форда (нахождения кратчайшего (s, t)-пути в графе с произвольными весами дуг):
 - алгоритм находит длины кратчайших (s, t)-путей в не-/ориентированном [взвешенном] графе G(V, E, [c])
   (в [] опциональные параметры)
 - алгоритм может не находить кратчайшие пути в случае, когда в графе есть циклы отрицательной длины
 Для случая, когда отрицательного цикла нетЖ
    - заводим массив D[0, ..., v-1] - расстояния (distance) после работы алгоритма
    - заполняем: D[s] = 0, D[v(i)] = +inf
    - алгоритм работает пошагово/пофазно:
        - на каждом шаге идет просмотр всех ребер графа и попытка релаксации вдоль ребра, то есть улучшения
        значения D[v2] значением D[v1] + c (то есть улучшаем/уменьшаем равное плюс бесконечности расстояние)
        - достаточно v - 1 шагов для получения кратчайших расстояний от вершины s до остальных вершин
        (поскольку кратчайший путь не может содержать большее число рёбер, иначе он содержит цикл)
        - для вершин, достичь которых невозможно, расстояние останется бесконечным
    - чтобы восстанавливать пути, заводим массив Prev, в котором будем хранить предков вершины
    - сложность алгоритма - O(V^2)

Моя реализация:

Вся сложность заключалась в том, что граф задан списками ПРЕДШ[], а не списками смежности, то есть по факту надо не
только корректно восстановить граф, но и запустить 'обратный' ход алгоритма (таким образом, у меня фактически start -
конечная вершина, target - начальная)

Кроме того, у меня предусмотрена проверка на отрицательный цикл и завершение работы по обнаружению такового.

- считываем данные из файла и парсим
- создаем словарь на основе ПРЕДШ[], чтобы восстановить граф для алгоритма Б-Ф
- по этому графу запускаем алгоритм Б-Ф:
    - помним, что у нас s - цель, t - начальная, иначе алгоритм некорректно отработает
    - заводим словари dist и previous для хранения дистанций и предков соответственно
    - заполняем их (dist[t] = 0, остальные - +inf; previous для всех пока None)
    - запускаем проверку расстояний вдоль ребер и меняем значения, если возможно
    - записываем обновленные значения в соответствующий словарь
- проверяем граф на наличие цмклов отрицательного веса:
    - в случае наличия отрицательного цикла выкидываем ошибку, потому что алгоритм иначе будет бесконечно уменьшать
    длину кратчайшего пути
- возвращаем dist и previous
- previous используется, чтобы восстановить путь повершинно (то есть список вершин от старта до финиша)
- dist используется, чтобы получить вычисленное расстояние
- результаты записываем в файл

В файле test.txt расширенный до 6 вершин граф, test_negative_cycle.txt - тестирует наличие отрицательного цикла на 3-х
вершинах
